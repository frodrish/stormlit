diff --git a/node_modules/@astrojs/starlight/utils/head.ts b/node_modules/@astrojs/starlight/utils/head.ts
index 85b74ad..00c9dc5 100644
--- a/node_modules/@astrojs/starlight/utils/head.ts
+++ b/node_modules/@astrojs/starlight/utils/head.ts
@@ -11,112 +11,113 @@ const HeadSchema = HeadConfigSchema({ source: 'content' });
 
 /** Get the head for the current page. */
 export function getHead(
-	{ entry, lang }: PageProps,
-	context: RouteDataContext,
-	siteTitle: string
+    { entry, lang }: PageProps,
+    context: RouteDataContext,
+    siteTitle: string
 ): HeadConfig {
-	const { data } = entry;
-
-	const canonical = context.site ? new URL(context.url.pathname, context.site) : undefined;
-	const canonicalHref = canonical?.href
-		? formatCanonical(canonical.href, {
-				format: project.build.format,
-				trailingSlash: project.trailingSlash,
-			})
-		: undefined;
-	const description = data.description || config.description;
-
-	const headDefaults: HeadUserConfig = [
-		{ tag: 'meta', attrs: { charset: 'utf-8' } },
-		{
-			tag: 'meta',
-			attrs: { name: 'viewport', content: 'width=device-width, initial-scale=1' },
-		},
-		{ tag: 'title', content: `${data.title} ${config.titleDelimiter} ${siteTitle}` },
-		{ tag: 'link', attrs: { rel: 'canonical', href: canonicalHref } },
-		{ tag: 'meta', attrs: { name: 'generator', content: context.generator } },
-		{
-			tag: 'meta',
-			attrs: { name: 'generator', content: `Starlight v${version}` },
-		},
-		// Favicon
-		{
-			tag: 'link',
-			attrs: {
-				rel: 'shortcut icon',
-				href: fileWithBase(config.favicon.href),
-				type: config.favicon.type,
-			},
-		},
-		// OpenGraph Tags
-		{ tag: 'meta', attrs: { property: 'og:title', content: data.title } },
-		{ tag: 'meta', attrs: { property: 'og:type', content: 'article' } },
-		{ tag: 'meta', attrs: { property: 'og:url', content: canonicalHref } },
-		{ tag: 'meta', attrs: { property: 'og:locale', content: lang } },
-		{ tag: 'meta', attrs: { property: 'og:description', content: description } },
-		{ tag: 'meta', attrs: { property: 'og:site_name', content: siteTitle } },
-		// Twitter Tags
-		{
-			tag: 'meta',
-			attrs: { name: 'twitter:card', content: 'summary_large_image' },
-		},
-	];
-
-	if (description)
-		headDefaults.push({
-			tag: 'meta',
-			attrs: { name: 'description', content: description },
-		});
-
-	// Link to language alternates.
-	if (canonical && config.isMultilingual) {
-		for (const locale in config.locales) {
-			const localeOpts = config.locales[locale];
-			if (!localeOpts) continue;
-			headDefaults.push({
-				tag: 'link',
-				attrs: {
-					rel: 'alternate',
-					hreflang: localeOpts.lang,
-					href: localizedUrl(canonical, locale, project.trailingSlash).href,
-				},
-			});
-		}
-	}
-
-	// Link to sitemap, but only when `site` is set.
-	if (context.site) {
-		headDefaults.push({
-			tag: 'link',
-			attrs: {
-				rel: 'sitemap',
-				href: fileWithBase('/sitemap-index.xml'),
-			},
-		});
-	}
-
-	// Link to Twitter account if set in Starlight config.
-	const twitterLink = config.social?.find(({ icon }) => icon === 'twitter' || icon === 'x.com');
-	if (twitterLink) {
-		headDefaults.push({
-			tag: 'meta',
-			attrs: {
-				name: 'twitter:site',
-				content: new URL(twitterLink.href).pathname.replace('/', '@'),
-			},
-		});
-	}
-
-	return createHead(headDefaults, config.head, data.head);
+    const { data } = entry;
+
+    const canonical = context.site ? new URL(context.url.pathname, context.site) : undefined;
+    const canonicalHref = canonical?.href
+        ? formatCanonical(canonical.href, {
+            format: project.build.format,
+            trailingSlash: project.trailingSlash,
+        })
+        : undefined;
+    const description = data.description || config.description;
+
+    const headDefaults: HeadUserConfig = [
+        { tag: 'meta', attrs: { charset: 'utf-8' } },
+        {
+            tag: 'meta',
+            attrs: { name: 'viewport', content: 'width=device-width, initial-scale=1' },
+        },
+        { tag: 'title', content: `${data.title} ${config.titleDelimiter} ${siteTitle}` },
+        { tag: 'link', attrs: { rel: 'canonical', href: canonicalHref } },
+        { tag: 'meta', attrs: { name: 'generator', content: context.generator } },
+        {
+            tag: 'meta',
+            attrs: { name: 'generator', content: `Starlight v${version}` },
+        },
+        // Favicon
+        {
+            tag: 'link',
+            attrs: {
+                rel: 'shortcut icon',
+                href: fileWithBase(config.favicon.href),
+                type: config.favicon.type,
+            },
+        },
+        // OpenGraph Tags
+        { tag: 'meta', attrs: { property: 'og:title', content: data.title } },
+        { tag: 'meta', attrs: { property: 'og:type', content: 'article' } },
+        { tag: 'meta', attrs: { property: 'og:url', content: canonicalHref } },
+        { tag: 'meta', attrs: { property: 'og:locale', content: lang } },
+        { tag: 'meta', attrs: { property: 'og:description', content: description } },
+        { tag: 'meta', attrs: { property: 'og:site_name', content: siteTitle } },
+        // Twitter Tags
+        {
+            tag: 'meta',
+            attrs: { name: 'twitter:card', content: 'summary_large_image' },
+        },
+    ];
+
+    if (description)
+        headDefaults.push({
+            tag: 'meta',
+            attrs: { name: 'description', content: description },
+        });
+
+    // Link to language alternates.
+    if (canonical && config.isMultilingual) {
+        for (const locale in config.locales) {
+            const localeOpts = config.locales[locale];
+            if (!localeOpts) continue;
+            headDefaults.push({
+                tag: 'link',
+                attrs: {
+                    rel: 'alternate',
+                    hreflang: localeOpts.lang,
+                    href: localizedUrl(canonical, locale, project.trailingSlash).href,
+                },
+            });
+        }
+    }
+
+    // Link to sitemap, but only when `site` is set.
+    if (context.site) {
+        headDefaults.push({
+            tag: 'link',
+            attrs: {
+                rel: 'sitemap',
+                href: fileWithBase('/sitemap-index.xml'),
+            },
+        });
+    }
+
+    // Link to Twitter account if set in Starlight config.
+    const twitterLink = config.social?.find(({ icon }) => icon === 'twitter' || icon === 'x.com');
+    if (twitterLink) {
+        headDefaults.push({
+            tag: 'meta',
+            attrs: {
+                name: 'twitter:site',
+                content: new URL(twitterLink.href).pathname.replace('/', '@'),
+            },
+        });
+    }
+
+    return createHead(headDefaults, config.head, data.head);
 }
 
 /** Create a fully parsed, merged, and sorted head entry array from multiple sources. */
 function createHead(defaults: HeadUserConfig, ...heads: HeadConfig[]) {
-	let head = HeadSchema.parse(defaults);
-	for (const next of heads) {
-		head = mergeHead(head, next);
-	}
-	return sortHead(head);
+    let head = HeadSchema.parse(defaults);
+    for (const next of heads) {
+        if(!next) continue;
+        head = mergeHead(head, next);
+    }
+    return sortHead(head);
 }
 
 /**
@@ -129,20 +130,20 @@ function createHead(defaults: HeadUserConfig, ...heads: HeadConfig[]) {
  * `property`, and `http-equiv` attributes for `<meta>` tags.
  */
 function hasTag(head: HeadConfig, entry: HeadConfig[number]): boolean {
-	switch (entry.tag) {
-		case 'title':
-			return head.some(({ tag }) => tag === 'title');
-		case 'meta':
-			return hasOneOf(head, entry, ['name', 'property', 'http-equiv']);
-		case 'link':
-			return head.some(
-				({ attrs }) =>
-					(entry.attrs?.rel === 'canonical' && attrs?.rel === 'canonical') ||
-					(entry.attrs?.rel === 'sitemap' && attrs?.rel === 'sitemap')
-			);
-		default:
-			return false;
-	}
+    switch (entry.tag) {
+        case 'title':
+            return head.some(({ tag }) => tag === 'title');
+        case 'meta':
+            return hasOneOf(head, entry, ['name', 'property', 'http-equiv']);
+        case 'link':
+            return head.some(
+                ({ attrs }) =>
+                    (entry.attrs?.rel === 'canonical' && attrs?.rel === 'canonical') ||
+                    (entry.attrs?.rel === 'sitemap' && attrs?.rel === 'sitemap')
+            );
+        default:
+            return false;
+    }
 }
 
 /**
@@ -150,69 +151,69 @@ function hasTag(head: HeadConfig, entry: HeadConfig[number]): boolean {
  * as `entry` and a matching attribute for one of the passed `keys`.
  */
 function hasOneOf(head: HeadConfig, entry: HeadConfig[number], keys: string[]): boolean {
-	const attr = getAttr(keys, entry);
-	if (!attr) return false;
-	const [key, val] = attr;
-	return head.some(({ tag, attrs }) => tag === entry.tag && attrs?.[key] === val);
+    const attr = getAttr(keys, entry);
+    if (!attr) return false;
+    const [key, val] = attr;
+    return head.some(({ tag, attrs }) => tag === entry.tag && attrs?.[key] === val);
 }
 
 /** Find the first matching key–value pair in a head entry’s attributes. */
 function getAttr(
-	keys: string[],
-	entry: HeadConfig[number]
+    keys: string[],
+    entry: HeadConfig[number]
 ): [key: string, value: string | boolean] | undefined {
-	let attr: [string, string | boolean] | undefined;
-	for (const key of keys) {
-		const val = entry.attrs?.[key];
-		if (val) {
-			attr = [key, val];
-			break;
-		}
-	}
-	return attr;
+    let attr: [string, string | boolean] | undefined;
+    for (const key of keys) {
+        const val = entry.attrs?.[key];
+        if (val) {
+            attr = [key, val];
+            break;
+        }
+    }
+    return attr;
 }
 
 /** Merge two heads, overwriting entries in the first head that exist in the second. */
 function mergeHead(oldHead: HeadConfig, newHead: HeadConfig) {
-	return [...oldHead.filter((tag) => !hasTag(newHead, tag)), ...newHead];
+    return [...oldHead.filter((tag) => !hasTag(newHead, tag)), ...newHead];
 }
 
 /** Sort head tags to place important tags first and relegate “SEO” meta tags. */
 function sortHead(head: HeadConfig) {
-	return head.sort((a, b) => {
-		const aImportance = getImportance(a);
-		const bImportance = getImportance(b);
-		return aImportance > bImportance ? -1 : bImportance > aImportance ? 1 : 0;
-	});
+    return head.sort((a, b) => {
+        const aImportance = getImportance(a);
+        const bImportance = getImportance(b);
+        return aImportance > bImportance ? -1 : bImportance > aImportance ? 1 : 0;
+    });
 }
 
 /** Get the relative importance of a specific head tag. */
 function getImportance(entry: HeadConfig[number]) {
-	// 1. Important meta tags.
-	if (
-		entry.tag === 'meta' &&
-		entry.attrs &&
-		('charset' in entry.attrs || 'http-equiv' in entry.attrs || entry.attrs.name === 'viewport')
-	) {
-		return 100;
-	}
-	// 2. Page title
-	if (entry.tag === 'title') return 90;
-	// 3. Anything that isn’t an SEO meta tag.
-	if (entry.tag !== 'meta') {
-		// The default favicon should be below any extra icons that the user may have set
-		// because if several icons are equally appropriate, the last one is used and we
-		// want to use the SVG icon when supported.
-		if (
-			entry.tag === 'link' &&
-			entry.attrs &&
-			'rel' in entry.attrs &&
-			entry.attrs.rel === 'shortcut icon'
-		) {
-			return 70;
-		}
-		return 80;
-	}
-	// 4. SEO meta tags.
-	return 0;
+    // 1. Important meta tags.
+    if (
+        entry.tag === 'meta' &&
+        entry.attrs &&
+        ('charset' in entry.attrs || 'http-equiv' in entry.attrs || entry.attrs.name === 'viewport')
+    ) {
+        return 100;
+    }
+    // 2. Page title
+    if (entry.tag === 'title') return 90;
+    // 3. Anything that isn’t an SEO meta tag.
+    if (entry.tag !== 'meta') {
+        // The default favicon should be below any extra icons that the user may have set
+        // because if several icons are equally appropriate, the last one is used and we
+        // want to use the SVG icon when supported.
+        if (
+            entry.tag === 'link' &&
+            entry.attrs &&
+            'rel' in entry.attrs &&
+            entry.attrs.rel === 'shortcut icon'
+        ) {
+            return 70;
+        }
+        return 80;
+    }
+    // 4. SEO meta tags.
+    return 0;
 }
diff --git a/node_modules/@astrojs/starlight/utils/navigation.ts b/node_modules/@astrojs/starlight/utils/navigation.ts
index 5fe09b8..f66acd8 100644
--- a/node_modules/@astrojs/starlight/utils/navigation.ts
+++ b/node_modules/@astrojs/starlight/utils/navigation.ts
@@ -4,29 +4,29 @@ import config from 'virtual:starlight/user-config';
 import type { Badge, I18nBadge, I18nBadgeConfig } from '../schemas/badge';
 import type { PrevNextLinkConfig } from '../schemas/prevNextLink';
 import type {
-	AutoSidebarGroup,
-	InternalSidebarLinkItem,
-	LinkHTMLAttributes,
-	SidebarItem,
-	SidebarLinkItem,
+    AutoSidebarGroup,
+    InternalSidebarLinkItem,
+    LinkHTMLAttributes,
+    SidebarItem,
+    SidebarLinkItem,
 } from '../schemas/sidebar';
 import { getCollectionPathFromRoot } from './collection';
 import { createPathFormatter } from './createPathFormatter';
 import { formatPath } from './format-path';
 import { BuiltInDefaultLocale, pickLang } from './i18n';
 import {
-	ensureLeadingSlash,
-	ensureTrailingSlash,
-	stripExtension,
-	stripLeadingAndTrailingSlashes,
+    ensureLeadingSlash,
+    ensureTrailingSlash,
+    stripExtension,
+    stripLeadingAndTrailingSlashes,
 } from './path';
 import { getLocaleRoutes, routes } from './routing';
 import type {
-	SidebarGroup,
-	SidebarLink,
-	PaginationLinks,
-	Route,
-	SidebarEntry,
+    SidebarGroup,
+    SidebarLink,
+    PaginationLinks,
+    Route,
+    SidebarEntry,
 } from './routing/types';
 import { localeToLang, localizedId, slugToPathname } from './slugs';
 import type { StarlightConfig } from './user-config';
@@ -45,83 +45,83 @@ const docsCollectionPathFromRoot = getCollectionPathFromRoot('docs', project);
  * is the full entry.
  */
 interface Dir {
-	[DirKey]: undefined;
-	[SlugKey]: string;
-	[item: string]: Dir | Route;
+    [DirKey]: undefined;
+    [SlugKey]: string;
+    [item: string]: Dir | Route;
 }
 
 /** Create a new directory object. */
 function makeDir(slug: string): Dir {
-	const dir = {} as Dir;
-	// Add DirKey and SlugKey as non-enumerable properties so that `Object.entries(dir)` ignores them.
-	Object.defineProperty(dir, DirKey, { enumerable: false });
-	Object.defineProperty(dir, SlugKey, { value: slug, enumerable: false });
-	return dir;
+    const dir = {} as Dir;
+    // Add DirKey and SlugKey as non-enumerable properties so that `Object.entries(dir)` ignores them.
+    Object.defineProperty(dir, DirKey, { enumerable: false });
+    Object.defineProperty(dir, SlugKey, { value: slug, enumerable: false });
+    return dir;
 }
 
 /** Test if the passed object is a directory record.  */
 function isDir(data: Record<string, unknown>): data is Dir {
-	return DirKey in data;
+    return DirKey in data;
 }
 
 /** Convert an item in a user’s sidebar config to a sidebar entry. */
 function configItemToEntry(
-	item: SidebarItem,
-	currentPathname: string,
-	locale: string | undefined,
-	routes: Route[]
+    item: SidebarItem,
+    currentPathname: string,
+    locale: string | undefined,
+    routes: Route[]
 ): SidebarEntry {
-	if ('link' in item) {
-		return linkFromSidebarLinkItem(item, locale);
-	} else if ('autogenerate' in item) {
-		return groupFromAutogenerateConfig(item, locale, routes, currentPathname);
-	} else if ('slug' in item) {
-		return linkFromInternalSidebarLinkItem(item, locale);
-	} else {
-		const label = pickLang(item.translations, localeToLang(locale)) || item.label;
-		return {
-			type: 'group',
-			label,
-			entries: item.items.map((i) => configItemToEntry(i, currentPathname, locale, routes)),
-			collapsed: item.collapsed,
-			badge: getSidebarBadge(item.badge, locale, label),
-		};
-	}
+    if ('link' in item) {
+        return linkFromSidebarLinkItem(item, locale);
+    } else if ('autogenerate' in item) {
+        return groupFromAutogenerateConfig(item, locale, routes, currentPathname);
+    } else if ('slug' in item) {
+        return linkFromInternalSidebarLinkItem(item, locale);
+    } else {
+        const label = pickLang(item.translations, localeToLang(locale)) || item.label;
+        return {
+            type: 'group',
+            label,
+            entries: item.items.map((i) => configItemToEntry(i, currentPathname, locale, routes)),
+            collapsed: item.collapsed,
+            badge: getSidebarBadge(item.badge, locale, label),
+        };
+    }
 }
 
 /** Autogenerate a group of links from a user’s sidebar config. */
 function groupFromAutogenerateConfig(
-	item: AutoSidebarGroup,
-	locale: string | undefined,
-	routes: Route[],
-	currentPathname: string
+    item: AutoSidebarGroup,
+    locale: string | undefined,
+    routes: Route[],
+    currentPathname: string
 ): SidebarGroup {
-	const { attrs, collapsed: subgroupCollapsed, directory } = item.autogenerate;
-	const localeDir = locale ? locale + '/' + directory : directory;
-	const dirDocs = routes.filter((doc) => {
-		const filePathFromContentDir = getRoutePathRelativeToCollectionRoot(doc, locale);
-		return (
-			// Match against `foo.md` or `foo/index.md`.
-			stripExtension(filePathFromContentDir) === localeDir ||
-			// Match against `foo/anything/else.md`.
-			filePathFromContentDir.startsWith(localeDir + '/')
-		);
-	});
-	const tree = treeify(dirDocs, locale, localeDir);
-	const label = pickLang(item.translations, localeToLang(locale)) || item.label;
-	return {
-		type: 'group',
-		label,
-		entries: sidebarFromDir(
-			tree,
-			currentPathname,
-			locale,
-			subgroupCollapsed ?? item.collapsed,
-			attrs
-		),
-		collapsed: item.collapsed,
-		badge: getSidebarBadge(item.badge, locale, label),
-	};
+    const { attrs, collapsed: subgroupCollapsed, directory } = item.autogenerate;
+    const localeDir = locale ? locale + '/' + directory : directory;
+    const dirDocs = routes.filter((doc) => {
+        const filePathFromContentDir = getRoutePathRelativeToCollectionRoot(doc, locale);
+        return (
+            // Match against `foo.md` or `foo/index.md`.
+            stripExtension(filePathFromContentDir) === localeDir ||
+            // Match against `foo/anything/else.md`.
+            filePathFromContentDir.startsWith(localeDir + '/')
+        );
+    });
+    const tree = treeify(dirDocs, locale, localeDir);
+    const label = pickLang(item.translations, localeToLang(locale)) || item.label;
+    return {
+        type: 'group',
+        label,
+        entries: sidebarFromDir(
+            tree,
+            currentPathname,
+            locale,
+            subgroupCollapsed ?? item.collapsed,
+            attrs
+        ),
+        collapsed: item.collapsed,
+        badge: getSidebarBadge(item.badge, locale, label),
+    };
 }
 
 /** Check if a string starts with one of `http://` or `https://`. */
@@ -129,158 +129,167 @@ const isAbsolute = (link: string) => /^https?:\/\//.test(link);
 
 /** Create a link entry from a manual link item in user config. */
 function linkFromSidebarLinkItem(item: SidebarLinkItem, locale: string | undefined) {
-	let href = item.link;
-	if (!isAbsolute(href)) {
-		href = ensureLeadingSlash(href);
-		// Inject current locale into link.
-		if (locale) href = '/' + locale + href;
-	}
-	const label = pickLang(item.translations, localeToLang(locale)) || item.label;
-	return makeSidebarLink(href, label, getSidebarBadge(item.badge, locale, label), item.attrs);
+    let href = item.link;
+    if (!isAbsolute(href)) {
+        href = ensureLeadingSlash(href);
+        // Inject current locale into link.
+        if (locale) href = '/' + locale + href;
+    }
+    const label = pickLang(item.translations, localeToLang(locale)) || item.label;
+    return makeSidebarLink(href, label, getSidebarBadge(item.badge, locale, label), item.attrs);
+}
+
+function transformPath(path :string):string {
+    const idx = path.lastIndexOf('/');
+    const lastSegment = idx !== -1 ? path.substring(idx + 1) : path;
+    return lastSegment.charAt(0).toUpperCase() + lastSegment.slice(1);
 }
 
 /** Create a link entry from an automatic internal link item in user config. */
 function linkFromInternalSidebarLinkItem(
-	item: InternalSidebarLinkItem,
-	locale: string | undefined
+    item: InternalSidebarLinkItem,
+    locale: string | undefined
 ) {
-	// Astro passes root `index.[md|mdx]` entries with a slug of `index`
-	const slug = item.slug === 'index' ? '' : item.slug;
-	const localizedSlug = locale ? (slug ? locale + '/' + slug : locale) : slug;
-	const route = routes.find((entry) => localizedSlug === entry.slug);
-	if (!route) {
-		const hasExternalSlashes = item.slug.at(0) === '/' || item.slug.at(-1) === '/';
-		if (hasExternalSlashes) {
-			throw new AstroError(
-				`The slug \`"${item.slug}"\` specified in the Starlight sidebar config must not start or end with a slash.`,
-				`Please try updating \`"${item.slug}"\` to \`"${stripLeadingAndTrailingSlashes(item.slug)}"\`.`
-			);
-		} else {
-			throw new AstroError(
-				`The slug \`"${item.slug}"\` specified in the Starlight sidebar config does not exist.`,
-				'Update the Starlight config to reference a valid entry slug in the docs content collection.\n' +
-					'Learn more about Astro content collection slugs at https://docs.astro.build/en/reference/modules/astro-content/#getentry'
-			);
-		}
-	}
-	const frontmatter = route.entry.data;
-	const label =
-		pickLang(item.translations, localeToLang(locale)) ||
-		item.label ||
-		frontmatter.sidebar?.label ||
-		frontmatter.title;
-	const badge = item.badge ?? frontmatter.sidebar?.badge;
-	const attrs = { ...frontmatter.sidebar?.attrs, ...item.attrs };
-	return makeSidebarLink(
-		slugToPathname(route.slug),
-		label,
-		getSidebarBadge(badge, locale, label),
-		attrs
-	);
+    // Astro passes root `index.[md|mdx]` entries with a slug of `index`
+    const slug = item.slug === 'index' ? '' : item.slug;
+    const localizedSlug = locale ? (slug ? locale + '/' + slug : locale) : slug;
+    const route = routes.find((entry) => localizedSlug === entry.slug);
+    if (!route) {
+        const hasExternalSlashes = item.slug.at(0) === '/' || item.slug.at(-1) === '/';
+        if (hasExternalSlashes) {
+            throw new AstroError(
+                `The slug \`"${item.slug}"\` specified in the Starlight sidebar config must not start or end with a slash.`,
+                `Please try updating \`"${item.slug}"\` to \`"${stripLeadingAndTrailingSlashes(item.slug)}"\`.`
+            );
+        } else {
+            throw new AstroError(
+                `The slug \`"${item.slug}"\` specified in the Starlight sidebar config does not exist.`,
+                'Update the Starlight config to reference a valid entry slug in the docs content collection.\n' +
+                'Learn more about Astro content collection slugs at https://docs.astro.build/en/reference/modules/astro-content/#getentry'
+            );
+        }
+    }
+    const frontmatter = route.entry.data;
+    const label =
+        pickLang(item.translations, localeToLang(locale)) ||
+        item.label ||
+        getLabel(route);
+    const badge = item.badge ?? frontmatter?.sidebar?.badge;
+    const attrs = { ...frontmatter?.sidebar?.attrs, ...item.attrs };
+    return makeSidebarLink(
+        slugToPathname(route.slug),
+        label,
+        getSidebarBadge(badge, locale, label),
+        attrs
+    );
 }
 
 /** Process sidebar link options to create a link entry. */
 function makeSidebarLink(
-	href: string,
-	label: string,
-	badge?: Badge,
-	attrs?: LinkHTMLAttributes
+    href: string,
+    label: string,
+    badge?: Badge,
+    attrs?: LinkHTMLAttributes
 ): SidebarLink {
-	if (!isAbsolute(href)) {
-		href = formatPath(href);
-	}
-	return makeLink({ label, href, badge, attrs });
+    if (!isAbsolute(href)) {
+        href = formatPath(href);
+    }
+    return makeLink({ label, href, badge, attrs });
 }
 
 /** Create a link entry */
 function makeLink({
-	attrs = {},
-	badge = undefined,
-	...opts
-}: {
-	label: string;
-	href: string;
-	badge?: Badge | undefined;
-	attrs?: LinkHTMLAttributes | undefined;
+                      attrs = {},
+                      badge = undefined,
+                      ...opts
+                  }: {
+    label: string;
+    href: string;
+    badge?: Badge | undefined;
+    attrs?: LinkHTMLAttributes | undefined;
 }): SidebarLink {
-	return { type: 'link', ...opts, badge, isCurrent: false, attrs };
+    return { type: 'link', ...opts, badge, isCurrent: false, attrs };
 }
 
 /** Test if two paths are equivalent even if formatted differently. */
 function pathsMatch(pathA: string, pathB: string) {
-	return neverPathFormatter(pathA) === neverPathFormatter(pathB);
+    return neverPathFormatter(pathA) === neverPathFormatter(pathB);
 }
 
 /** Get the segments leading to a page. */
 function getBreadcrumbs(path: string, baseDir: string): string[] {
-	// Strip extension from path.
-	const pathWithoutExt = stripExtension(path);
-	// Index paths will match `baseDir` and don’t include breadcrumbs.
-	if (pathWithoutExt === baseDir) return [];
-	// Ensure base directory ends in a trailing slash.
-	baseDir = ensureTrailingSlash(baseDir);
-	// Strip base directory from path if present.
-	const relativePath = pathWithoutExt.startsWith(baseDir)
-		? pathWithoutExt.replace(baseDir, '')
-		: pathWithoutExt;
-
-	return relativePath.split('/');
+    // Strip extension from path.
+    const pathWithoutExt = stripExtension(path);
+    // Index paths will match `baseDir` and don’t include breadcrumbs.
+    if (pathWithoutExt === baseDir) return [];
+    // Ensure base directory ends in a trailing slash.
+    baseDir = ensureTrailingSlash(baseDir);
+    // Strip base directory from path if present.
+    const relativePath = pathWithoutExt.startsWith(baseDir)
+        ? pathWithoutExt.replace(baseDir, '')
+        : pathWithoutExt;
+
+    return relativePath.split('/');
 }
 
 /** Return the path of a route relative to the root of the collection, which is equivalent to legacy IDs. */
 function getRoutePathRelativeToCollectionRoot(route: Route, locale: string | undefined) {
-	return project.legacyCollections
-		? route.id
-		: // For collections with a loader, use a localized filePath relative to the collection
-			localizedId(route.entry.filePath.replace(`${docsCollectionPathFromRoot}/`, ''), locale);
+    return project.legacyCollections
+        ? route.id
+        : // For collections with a loader, use a localized filePath relative to the collection
+        localizedId(route.entry.filePath.replace(`${docsCollectionPathFromRoot}/`, ''), locale);
 }
 
 /** Turn a flat array of routes into a tree structure. */
 function treeify(routes: Route[], locale: string | undefined, baseDir: string): Dir {
-	const treeRoot: Dir = makeDir(baseDir);
-	routes
-		// Remove any entries that should be hidden
-		.filter((doc) => !doc.entry.data.sidebar.hidden)
-		// Compute the path of each entry from the root of the collection ahead of time.
-		.map((doc) => [getRoutePathRelativeToCollectionRoot(doc, locale), doc] as const)
-		// Sort by depth, to build the tree depth first.
-		.sort(([a], [b]) => b.split('/').length - a.split('/').length)
-		// Build the tree
-		.forEach(([filePathFromContentDir, doc]) => {
-			const parts = getBreadcrumbs(filePathFromContentDir, baseDir);
-			let currentNode = treeRoot;
-
-			parts.forEach((part, index) => {
-				const isLeaf = index === parts.length - 1;
-
-				// Handle directory index pages by renaming them to `index`
-				if (isLeaf && Object.hasOwn(currentNode, part)) {
-					currentNode = currentNode[part] as Dir;
-					part = 'index';
-				}
-
-				// Recurse down the tree if this isn’t the leaf node.
-				if (!isLeaf) {
-					const path = currentNode[SlugKey];
-					currentNode[part] ||= makeDir(stripLeadingAndTrailingSlashes(path + '/' + part));
-					currentNode = currentNode[part] as Dir;
-				} else {
-					currentNode[part] = doc;
-				}
-			});
-		});
-
-	return treeRoot;
+    const treeRoot: Dir = makeDir(baseDir);
+    routes
+        // Remove any entries that should be hidden
+        .filter((doc) => !doc.entry.data.sidebar?.hidden)
+        // Compute the path of each entry from the root of the collection ahead of time.
+        .map((doc) => [getRoutePathRelativeToCollectionRoot(doc, locale), doc] as const)
+        // Sort by depth, to build the tree depth first.
+        .sort(([a], [b]) => b.split('/').length - a.split('/').length)
+        // Build the tree
+        .forEach(([filePathFromContentDir, doc]) => {
+            const parts = getBreadcrumbs(filePathFromContentDir, baseDir);
+            let currentNode = treeRoot;
+
+            parts.forEach((part, index) => {
+                const isLeaf = index === parts.length - 1;
+
+                // Handle directory index pages by renaming them to `index`
+                if (isLeaf && Object.hasOwn(currentNode, part)) {
+                    currentNode = currentNode[part] as Dir;
+                    part = 'index';
+                }
+
+                // Recurse down the tree if this isn’t the leaf node.
+                if (!isLeaf) {
+                    const path = currentNode[SlugKey];
+                    currentNode[part] ||= makeDir(stripLeadingAndTrailingSlashes(path + '/' + part));
+                    currentNode = currentNode[part] as Dir;
+                } else {
+                    currentNode[part] = doc;
+                }
+            });
+        });
+
+    return treeRoot;
+}
+
+function getLabel(route: Route) {
+    return route.entry.data?.sidebar?.label || route.entry.data?.title || transformPath(route.entry.id);
 }
 
 /** Create a link entry for a given content collection entry. */
 function linkFromRoute(route: Route, attrs?: LinkHTMLAttributes): SidebarLink {
-	return makeSidebarLink(
-		slugToPathname(route.slug),
-		route.entry.data.sidebar.label || route.entry.data.title,
-		route.entry.data.sidebar.badge,
-		{ ...attrs, ...route.entry.data.sidebar.attrs }
-	);
+    return makeSidebarLink(
+        slugToPathname(route.slug),
+        getLabel(route),
+        route.entry.data.sidebar?.badge,
+        { ...attrs, ...route.entry.data.sidebar?.attrs }
+    );
 }
 
 /**
@@ -288,72 +297,72 @@ function linkFromRoute(route: Route, attrs?: LinkHTMLAttributes): SidebarLink {
  * Directories have the weight of the lowest weighted route they contain.
  */
 function getOrder(routeOrDir: Route | Dir): number {
-	return isDir(routeOrDir)
-		? Math.min(...Object.values(routeOrDir).flatMap(getOrder))
-		: // If no order value is found, set it to the largest number possible.
-			(routeOrDir.entry.data.sidebar.order ?? Number.MAX_VALUE);
+    return isDir(routeOrDir)
+        ? Math.min(...Object.values(routeOrDir).flatMap(getOrder))
+        : // If no order value is found, set it to the largest number possible.
+        (routeOrDir.entry.data.sidebar?.order ?? Number.MAX_VALUE);
 }
 
 /** Sort a directory’s entries by user-specified order or alphabetically if no order specified. */
 function sortDirEntries(dir: [string, Dir | Route][]): [string, Dir | Route][] {
-	const collator = new Intl.Collator(localeToLang(undefined));
-	return dir.sort(([_keyA, a], [_keyB, b]) => {
-		const [aOrder, bOrder] = [getOrder(a), getOrder(b)];
-		// Pages are sorted by order in ascending order.
-		if (aOrder !== bOrder) return aOrder < bOrder ? -1 : 1;
-		// If two pages have the same order value they will be sorted by their slug.
-		return collator.compare(isDir(a) ? a[SlugKey] : a.slug, isDir(b) ? b[SlugKey] : b.slug);
-	});
+    const collator = new Intl.Collator(localeToLang(undefined));
+    return dir.sort(([_keyA, a], [_keyB, b]) => {
+        const [aOrder, bOrder] = [getOrder(a), getOrder(b)];
+        // Pages are sorted by order in ascending order.
+        if (aOrder !== bOrder) return aOrder < bOrder ? -1 : 1;
+        // If two pages have the same order value they will be sorted by their slug.
+        return collator.compare(isDir(a) ? a[SlugKey] : a.slug, isDir(b) ? b[SlugKey] : b.slug);
+    });
 }
 
 /** Create a group entry for a given content collection directory. */
 function groupFromDir(
-	dir: Dir,
-	fullPath: string,
-	dirName: string,
-	currentPathname: string,
-	locale: string | undefined,
-	collapsed: boolean,
-	attrs?: LinkHTMLAttributes
+    dir: Dir,
+    fullPath: string,
+    dirName: string,
+    currentPathname: string,
+    locale: string | undefined,
+    collapsed: boolean,
+    attrs?: LinkHTMLAttributes
 ): SidebarGroup {
-	const entries = sortDirEntries(Object.entries(dir)).map(([key, dirOrRoute]) =>
-		dirToItem(dirOrRoute, `${fullPath}/${key}`, key, currentPathname, locale, collapsed, attrs)
-	);
-	return {
-		type: 'group',
-		label: dirName,
-		entries,
-		collapsed,
-		badge: undefined,
-	};
+    const entries = sortDirEntries(Object.entries(dir)).map(([key, dirOrRoute]) =>
+        dirToItem(dirOrRoute, `${fullPath}/${key}`, key, currentPathname, locale, collapsed, attrs)
+    );
+    return {
+        type: 'group',
+        label: dirName,
+        entries,
+        collapsed,
+        badge: undefined,
+    };
 }
 
 /** Create a sidebar entry for a directory or content entry. */
 function dirToItem(
-	dirOrRoute: Dir[string],
-	fullPath: string,
-	dirName: string,
-	currentPathname: string,
-	locale: string | undefined,
-	collapsed: boolean,
-	attrs?: LinkHTMLAttributes
+    dirOrRoute: Dir[string],
+    fullPath: string,
+    dirName: string,
+    currentPathname: string,
+    locale: string | undefined,
+    collapsed: boolean,
+    attrs?: LinkHTMLAttributes
 ): SidebarEntry {
-	return isDir(dirOrRoute)
-		? groupFromDir(dirOrRoute, fullPath, dirName, currentPathname, locale, collapsed, attrs)
-		: linkFromRoute(dirOrRoute, attrs);
+    return isDir(dirOrRoute)
+        ? groupFromDir(dirOrRoute, fullPath, dirName, currentPathname, locale, collapsed, attrs)
+        : linkFromRoute(dirOrRoute, attrs);
 }
 
 /** Create a sidebar entry for a given content directory. */
 function sidebarFromDir(
-	tree: Dir,
-	currentPathname: string,
-	locale: string | undefined,
-	collapsed: boolean,
-	attrs?: LinkHTMLAttributes
+    tree: Dir,
+    currentPathname: string,
+    locale: string | undefined,
+    collapsed: boolean,
+    attrs?: LinkHTMLAttributes
 ) {
-	return sortDirEntries(Object.entries(tree)).map(([key, dirOrRoute]) =>
-		dirToItem(dirOrRoute, key, key, currentPathname, locale, collapsed, attrs)
-	);
+    return sortDirEntries(Object.entries(tree)).map(([key, dirOrRoute]) =>
+        dirToItem(dirOrRoute, key, key, currentPathname, locale, collapsed, attrs)
+    );
 }
 
 /**
@@ -369,180 +378,180 @@ const intermediateSidebars = new Map<string | undefined, SidebarEntry[]>();
 
 /** Get the sidebar for the current page using the global config. */
 export function getSidebar(pathname: string, locale: string | undefined): SidebarEntry[] {
-	let intermediateSidebar = intermediateSidebars.get(locale);
-	if (!intermediateSidebar) {
-		intermediateSidebar = getIntermediateSidebarFromConfig(config.sidebar, pathname, locale);
-		intermediateSidebars.set(locale, intermediateSidebar);
-	}
-	return getSidebarFromIntermediateSidebar(intermediateSidebar, pathname);
+    let intermediateSidebar = intermediateSidebars.get(locale);
+    if (!intermediateSidebar) {
+        intermediateSidebar = getIntermediateSidebarFromConfig(config.sidebar, pathname, locale);
+        intermediateSidebars.set(locale, intermediateSidebar);
+    }
+    return getSidebarFromIntermediateSidebar(intermediateSidebar, pathname);
 }
 
 /** Get the sidebar for the current page using the specified sidebar config. */
 export function getSidebarFromConfig(
-	sidebarConfig: StarlightConfig['sidebar'],
-	pathname: string,
-	locale: string | undefined
+    sidebarConfig: StarlightConfig['sidebar'],
+    pathname: string,
+    locale: string | undefined
 ): SidebarEntry[] {
-	const intermediateSidebar = getIntermediateSidebarFromConfig(sidebarConfig, pathname, locale);
-	return getSidebarFromIntermediateSidebar(intermediateSidebar, pathname);
+    const intermediateSidebar = getIntermediateSidebarFromConfig(sidebarConfig, pathname, locale);
+    return getSidebarFromIntermediateSidebar(intermediateSidebar, pathname);
 }
 
 /** Get the intermediate sidebar for the current page using the specified sidebar config. */
 function getIntermediateSidebarFromConfig(
-	sidebarConfig: StarlightConfig['sidebar'],
-	pathname: string,
-	locale: string | undefined
+    sidebarConfig: StarlightConfig['sidebar'],
+    pathname: string,
+    locale: string | undefined
 ): SidebarEntry[] {
-	const routes = getLocaleRoutes(locale);
-	if (sidebarConfig) {
-		return sidebarConfig.map((group) => configItemToEntry(group, pathname, locale, routes));
-	} else {
-		const tree = treeify(routes, locale, locale || '');
-		return sidebarFromDir(tree, pathname, locale, false);
-	}
+    const routes = getLocaleRoutes(locale);
+    if (sidebarConfig) {
+        return sidebarConfig.map((group) => configItemToEntry(group, pathname, locale, routes));
+    } else {
+        const tree = treeify(routes, locale, locale || '');
+        return sidebarFromDir(tree, pathname, locale, false);
+    }
 }
 
 /** Transform an intermediate sidebar into a sidebar for the current page. */
 function getSidebarFromIntermediateSidebar(
-	intermediateSidebar: SidebarEntry[],
-	pathname: string
+    intermediateSidebar: SidebarEntry[],
+    pathname: string
 ): SidebarEntry[] {
-	const sidebar = structuredClone(intermediateSidebar);
-	setIntermediateSidebarCurrentEntry(sidebar, pathname);
-	return sidebar;
+    const sidebar = structuredClone(intermediateSidebar);
+    setIntermediateSidebarCurrentEntry(sidebar, pathname);
+    return sidebar;
 }
 
 /** Marks the current page as such in an intermediate sidebar. */
 function setIntermediateSidebarCurrentEntry(
-	intermediateSidebar: SidebarEntry[],
-	pathname: string
+    intermediateSidebar: SidebarEntry[],
+    pathname: string
 ): boolean {
-	for (const entry of intermediateSidebar) {
-		if (entry.type === 'link' && pathsMatch(encodeURI(entry.href), pathname)) {
-			entry.isCurrent = true;
-			return true;
-		}
-
-		if (entry.type === 'group' && setIntermediateSidebarCurrentEntry(entry.entries, pathname)) {
-			return true;
-		}
-	}
-	return false;
+    for (const entry of intermediateSidebar) {
+        if (entry.type === 'link' && pathsMatch(encodeURI(entry.href), pathname)) {
+            entry.isCurrent = true;
+            return true;
+        }
+
+        if (entry.type === 'group' && setIntermediateSidebarCurrentEntry(entry.entries, pathname)) {
+            return true;
+        }
+    }
+    return false;
 }
 
 /** Generates a deterministic string based on the content of the passed sidebar. */
 export function getSidebarHash(sidebar: SidebarEntry[]): string {
-	let hash = 0;
-	const sidebarIdentity = recursivelyBuildSidebarIdentity(sidebar);
-	for (let i = 0; i < sidebarIdentity.length; i++) {
-		const char = sidebarIdentity.charCodeAt(i);
-		hash = (hash << 5) - hash + char;
-	}
-	return (hash >>> 0).toString(36).padStart(7, '0');
+    let hash = 0;
+    const sidebarIdentity = recursivelyBuildSidebarIdentity(sidebar);
+    for (let i = 0; i < sidebarIdentity.length; i++) {
+        const char = sidebarIdentity.charCodeAt(i);
+        hash = (hash << 5) - hash + char;
+    }
+    return (hash >>> 0).toString(36).padStart(7, '0');
 }
 
 /** Recurses through a sidebar tree to generate a string concatenating labels and link hrefs. */
 function recursivelyBuildSidebarIdentity(sidebar: SidebarEntry[]): string {
-	return sidebar
-		.flatMap((entry) =>
-			entry.type === 'group'
-				? entry.label + recursivelyBuildSidebarIdentity(entry.entries)
-				: entry.label + entry.href
-		)
-		.join('');
+    return sidebar
+        .flatMap((entry) =>
+            entry.type === 'group'
+                ? entry.label + recursivelyBuildSidebarIdentity(entry.entries)
+                : entry.label + entry.href
+        )
+        .join('');
 }
 
 /** Turn the nested tree structure of a sidebar into a flat list of all the links. */
 export function flattenSidebar(sidebar: SidebarEntry[]): SidebarLink[] {
-	return sidebar.flatMap((entry) =>
-		entry.type === 'group' ? flattenSidebar(entry.entries) : entry
-	);
+    return sidebar.flatMap((entry) =>
+        entry.type === 'group' ? flattenSidebar(entry.entries) : entry
+    );
 }
 
 /** Get previous/next pages in the sidebar or the ones from the frontmatter if any. */
 export function getPrevNextLinks(
-	sidebar: SidebarEntry[],
-	paginationEnabled: boolean,
-	config: {
-		prev?: PrevNextLinkConfig;
-		next?: PrevNextLinkConfig;
-	}
+    sidebar: SidebarEntry[],
+    paginationEnabled: boolean,
+    config: {
+        prev?: PrevNextLinkConfig;
+        next?: PrevNextLinkConfig;
+    }
 ): PaginationLinks {
-	const entries = flattenSidebar(sidebar);
-	const currentIndex = entries.findIndex((entry) => entry.isCurrent);
-	const prev = applyPrevNextLinkConfig(entries[currentIndex - 1], paginationEnabled, config.prev);
-	const next = applyPrevNextLinkConfig(
-		currentIndex > -1 ? entries[currentIndex + 1] : undefined,
-		paginationEnabled,
-		config.next
-	);
-	return { prev, next };
+    const entries = flattenSidebar(sidebar);
+    const currentIndex = entries.findIndex((entry) => entry.isCurrent);
+    const prev = applyPrevNextLinkConfig(entries[currentIndex - 1], paginationEnabled, config.prev);
+    const next = applyPrevNextLinkConfig(
+        currentIndex > -1 ? entries[currentIndex + 1] : undefined,
+        paginationEnabled,
+        config.next
+    );
+    return { prev, next };
 }
 
 /** Apply a prev/next link config to a navigation link. */
 function applyPrevNextLinkConfig(
-	link: SidebarLink | undefined,
-	paginationEnabled: boolean,
-	config: PrevNextLinkConfig | undefined
+    link: SidebarLink | undefined,
+    paginationEnabled: boolean,
+    config: PrevNextLinkConfig | undefined
 ): SidebarLink | undefined {
-	// Explicitly remove the link.
-	if (config === false) return undefined;
-	// Use the generated link if any.
-	else if (config === true) return link;
-	// If a link exists, update its label if needed.
-	else if (typeof config === 'string' && link) {
-		return { ...link, label: config };
-	} else if (typeof config === 'object') {
-		if (link) {
-			// If a link exists, update both its label and href if needed.
-			return {
-				...link,
-				label: config.label ?? link.label,
-				href: config.link ?? link.href,
-				// Explicitly remove sidebar link attributes for prev/next links.
-				attrs: {},
-			};
-		} else if (config.link && config.label) {
-			// If there is no link and the frontmatter contains both a URL and a label,
-			// create a new link.
-			return makeLink({ href: config.link, label: config.label });
-		}
-	}
-	// Otherwise, if the global config is enabled, return the generated link if any.
-	return paginationEnabled ? link : undefined;
+    // Explicitly remove the link.
+    if (config === false) return undefined;
+    // Use the generated link if any.
+    else if (config === true) return link;
+    // If a link exists, update its label if needed.
+    else if (typeof config === 'string' && link) {
+        return { ...link, label: config };
+    } else if (typeof config === 'object') {
+        if (link) {
+            // If a link exists, update both its label and href if needed.
+            return {
+                ...link,
+                label: config.label ?? link.label,
+                href: config.link ?? link.href,
+                // Explicitly remove sidebar link attributes for prev/next links.
+                attrs: {},
+            };
+        } else if (config.link && config.label) {
+            // If there is no link and the frontmatter contains both a URL and a label,
+            // create a new link.
+            return makeLink({ href: config.link, label: config.label });
+        }
+    }
+    // Otherwise, if the global config is enabled, return the generated link if any.
+    return paginationEnabled ? link : undefined;
 }
 
 /** Get a sidebar badge for a given item. */
 function getSidebarBadge(
-	config: I18nBadgeConfig,
-	locale: string | undefined,
-	itemLabel: string
+    config: I18nBadgeConfig,
+    locale: string | undefined,
+    itemLabel: string
 ): Badge | undefined {
-	if (!config) return;
-	if (typeof config === 'string') {
-		return { variant: 'default', text: config };
-	}
-	return { ...config, text: getSidebarBadgeText(config.text, locale, itemLabel) };
+    if (!config) return;
+    if (typeof config === 'string') {
+        return { variant: 'default', text: config };
+    }
+    return { ...config, text: getSidebarBadgeText(config.text, locale, itemLabel) };
 }
 
 /** Get the badge text for a sidebar item. */
 function getSidebarBadgeText(
-	text: I18nBadge['text'],
-	locale: string | undefined,
-	itemLabel: string
+    text: I18nBadge['text'],
+    locale: string | undefined,
+    itemLabel: string
 ): string {
-	if (typeof text === 'string') return text;
-	const defaultLang =
-		config.defaultLocale?.lang || config.defaultLocale?.locale || BuiltInDefaultLocale.lang;
-	const defaultText = text[defaultLang];
-
-	if (!defaultText) {
-		throw new AstroError(
-			`The badge text for "${itemLabel}" must have a key for the default language "${defaultLang}".`,
-			'Update the Starlight config to include a badge text for the default language.\n' +
-				'Learn more about sidebar badges internationalization at https://starlight.astro.build/guides/sidebar/#internationalization-with-badges'
-		);
-	}
-
-	return pickLang(text, localeToLang(locale)) || defaultText;
+    if (typeof text === 'string') return text;
+    const defaultLang =
+        config.defaultLocale?.lang || config.defaultLocale?.locale || BuiltInDefaultLocale.lang;
+    const defaultText = text[defaultLang];
+
+    if (!defaultText) {
+        throw new AstroError(
+            `The badge text for "${itemLabel}" must have a key for the default language "${defaultLang}".`,
+            'Update the Starlight config to include a badge text for the default language.\n' +
+            'Learn more about sidebar badges internationalization at https://starlight.astro.build/guides/sidebar/#internationalization-with-badges'
+        );
+    }
+
+    return pickLang(text, localeToLang(locale)) || defaultText;
 }
diff --git a/node_modules/@astrojs/starlight/utils/routing/index.ts b/node_modules/@astrojs/starlight/utils/routing/index.ts
index 460d15a..143f1cd 100644
--- a/node_modules/@astrojs/starlight/utils/routing/index.ts
+++ b/node_modules/@astrojs/starlight/utils/routing/index.ts
@@ -13,8 +13,8 @@ import type { Route, StarlightDocsCollectionEntry, StarlightDocsEntry } from './
 validateLogoImports();
 
 interface Path extends GetStaticPathsItem {
-	params: { slug: string | undefined };
-	props: Route;
+    params: { slug: string | undefined };
+    props: Route;
 }
 
 /**
@@ -26,88 +26,88 @@ const normalizeIndexSlug = (slug: string) => (slug === 'index' ? '' : slug);
 
 /** Normalize the different collection entry we can get from a legacy collection or a loader. */
 export function normalizeCollectionEntry(entry: StarlightDocsCollectionEntry): StarlightDocsEntry {
-	const slug = normalizeIndexSlug(entry.slug ?? entry.id);
-	return {
-		...entry,
-		// In a collection with a loader, the `id` is a slug and should be normalized.
-		id: entry.slug ? entry.id : slug,
-		// In a legacy collection, the `filePath` property doesn't exist.
-		filePath: entry.filePath ?? `${getCollectionPathFromRoot('docs', project)}/${entry.id}`,
-		// In a collection with a loader, the `slug` property is replaced by the `id`.
-		slug: normalizeIndexSlug(entry.slug ?? entry.id),
-	};
+    const slug = normalizeIndexSlug(entry.slug ?? entry.id);
+    return {
+        ...entry,
+        // In a collection with a loader, the `id` is a slug and should be normalized.
+        id: entry.slug ? entry.id : slug,
+        // In a legacy collection, the `filePath` property doesn't exist.
+        filePath: entry.filePath ?? `${getCollectionPathFromRoot('docs', project)}/${entry.id}`,
+        // In a collection with a loader, the `slug` property is replaced by the `id`.
+        slug: normalizeIndexSlug(entry.slug ?? entry.id),
+    };
 }
 
 /** All entries in the docs content collection. */
 const docs: StarlightDocsEntry[] = (
-	(await getCollection('docs', ({ data }) => {
-		// In production, filter out drafts.
-		return import.meta.env.MODE !== 'production' || data.draft === false;
-	})) ?? []
+    (await getCollection('docs', ({ data }) => {
+        // In production, filter out drafts.
+        return import.meta.env.MODE !== 'production' || data.draft != true;
+    })) ?? []
 ).map(normalizeCollectionEntry);
 
 function getRoutes(): Route[] {
-	const routes: Route[] = docs.map((entry) => ({
-		entry,
-		slug: entry.slug,
-		id: entry.id,
-		entryMeta: slugToLocaleData(entry.slug),
-		...slugToLocaleData(entry.slug),
-	}));
+    const routes: Route[] = docs.map((entry) => ({
+        entry,
+        slug: entry.slug,
+        id: entry.id,
+        entryMeta: slugToLocaleData(entry.slug),
+        ...slugToLocaleData(entry.slug),
+    }));
 
-	// In multilingual sites, add required fallback routes.
-	if (config.isMultilingual) {
-		/** Entries in the docs content collection for the default locale. */
-		const defaultLocaleDocs = getLocaleDocs(
-			config.defaultLocale?.locale === 'root' ? undefined : config.defaultLocale?.locale
-		);
-		for (const key in config.locales) {
-			if (key === config.defaultLocale.locale) continue;
-			const localeConfig = config.locales[key];
-			if (!localeConfig) continue;
-			const locale = key === 'root' ? undefined : key;
-			const localeDocs = getLocaleDocs(locale);
-			for (const fallback of defaultLocaleDocs) {
-				const slug = localizedSlug(fallback.slug, locale);
-				const id = project.legacyCollections ? localizedId(fallback.id, locale) : slug;
-				const doesNotNeedFallback = localeDocs.some((doc) => doc.slug === slug);
-				if (doesNotNeedFallback) continue;
-				routes.push({
-					entry: fallback,
-					slug,
-					id,
-					isFallback: true,
-					lang: localeConfig.lang || BuiltInDefaultLocale.lang,
-					locale,
-					dir: localeConfig.dir,
-					entryMeta: slugToLocaleData(fallback.slug),
-				});
-			}
-		}
-	}
+    // In multilingual sites, add required fallback routes.
+    if (config.isMultilingual) {
+        /** Entries in the docs content collection for the default locale. */
+        const defaultLocaleDocs = getLocaleDocs(
+            config.defaultLocale?.locale === 'root' ? undefined : config.defaultLocale?.locale
+        );
+        for (const key in config.locales) {
+            if (key === config.defaultLocale.locale) continue;
+            const localeConfig = config.locales[key];
+            if (!localeConfig) continue;
+            const locale = key === 'root' ? undefined : key;
+            const localeDocs = getLocaleDocs(locale);
+            for (const fallback of defaultLocaleDocs) {
+                const slug = localizedSlug(fallback.slug, locale);
+                const id = project.legacyCollections ? localizedId(fallback.id, locale) : slug;
+                const doesNotNeedFallback = localeDocs.some((doc) => doc.slug === slug);
+                if (doesNotNeedFallback) continue;
+                routes.push({
+                    entry: fallback,
+                    slug,
+                    id,
+                    isFallback: true,
+                    lang: localeConfig.lang || BuiltInDefaultLocale.lang,
+                    locale,
+                    dir: localeConfig.dir,
+                    entryMeta: slugToLocaleData(fallback.slug),
+                });
+            }
+        }
+    }
 
-	return routes;
+    return routes;
 }
 export const routes = getRoutes();
 
 function getParamRouteMapping(): ReadonlyMap<string | undefined, Route> {
-	const map = new Map<string | undefined, Route>();
-	for (const route of routes) {
-		map.set(slugToParam(route.slug), route);
-	}
-	return map;
+    const map = new Map<string | undefined, Route>();
+    for (const route of routes) {
+        map.set(slugToParam(route.slug), route);
+    }
+    return map;
 }
 const routesBySlugParam = getParamRouteMapping();
 
 export function getRouteBySlugParam(slugParam: string | undefined): Route | undefined {
-	return routesBySlugParam.get(slugParam?.replace(/\/$/, '') || undefined);
+    return routesBySlugParam.get(slugParam?.replace(/\/$/, '') || undefined);
 }
 
 function getPaths(): Path[] {
-	return routes.map((route) => ({
-		params: { slug: slugToParam(route.slug) },
-		props: route,
-	}));
+    return routes.map((route) => ({
+        params: { slug: slugToParam(route.slug) },
+        props: route,
+    }));
 }
 export const paths = getPaths();
 
@@ -116,7 +116,7 @@ export const paths = getPaths();
  * A locale of `undefined` is treated as the “root” locale, if configured.
  */
 export function getLocaleRoutes(locale: string | undefined): Route[] {
-	return filterByLocale(routes, locale);
+    return filterByLocale(routes, locale);
 }
 
 /**
@@ -124,20 +124,20 @@ export function getLocaleRoutes(locale: string | undefined): Route[] {
  * A locale of `undefined` is treated as the “root” locale, if configured.
  */
 function getLocaleDocs(locale: string | undefined): StarlightDocsEntry[] {
-	return filterByLocale(docs, locale);
+    return filterByLocale(docs, locale);
 }
 
 /** Filter an array to find items whose slug matches the passed locale. */
 function filterByLocale<T extends { slug: string }>(items: T[], locale: string | undefined): T[] {
-	if (config.locales) {
-		if (locale && locale in config.locales) {
-			return items.filter((i) => i.slug === locale || i.slug.startsWith(locale + '/'));
-		} else if (config.locales.root) {
-			const langKeys = Object.keys(config.locales).filter((k) => k !== 'root');
-			const isLangIndex = new RegExp(`^(${langKeys.join('|')})$`);
-			const isLangDir = new RegExp(`^(${langKeys.join('|')})/`);
-			return items.filter((i) => !isLangIndex.test(i.slug) && !isLangDir.test(i.slug));
-		}
-	}
-	return items;
+    if (config.locales) {
+        if (locale && locale in config.locales) {
+            return items.filter((i) => i.slug === locale || i.slug.startsWith(locale + '/'));
+        } else if (config.locales.root) {
+            const langKeys = Object.keys(config.locales).filter((k) => k !== 'root');
+            const isLangIndex = new RegExp(`^(${langKeys.join('|')})$`);
+            const isLangDir = new RegExp(`^(${langKeys.join('|')})/`);
+            return items.filter((i) => !isLangIndex.test(i.slug) && !isLangDir.test(i.slug));
+        }
+    }
+    return items;
 }
